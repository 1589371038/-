# 层序遍历（深度收集法！）

![image-20211106162425225](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211106162425225.png)

##### 思路1：深度收集法

思路：发现二叉树的中序遍历，其每一层数据的相对顺序，和层序遍历一样

举例          1                             depth  0

​            2        3                                      1

​     4     5      6     7                                 2

层序遍历：[1] [2,3] [4, 5,6,7]  中序遍历 4 2 5 1 6 3 7



先中序遍历并且记录<value,  depth >的二元组， 按顺序放到List里面

结果为：<4,2> <2,1> <5,2> <1,0> <6,2> <3,1> <7,2>



然后新建List<List<integer>> 容器中存储结果

在容器中新建最大深度个 List<Integer> 作为此层的容器



最后，遍历<4,2> <2,1> <5,2> <1,0> <6,2> <3,1> <7,2>结果，根据深度(第二个数字)，放入不同层的容器当中

代码

``

```java
public class 二叉树的层序遍历2 {
    int maxDep = 0;
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        List<List<Integer>> ValueAndDepth = new ArrayList<>();  //{{5节点值, 1深度},{4节点值, 2深度}} 中序遍历存储每个节点和深度

        midOrder(root, 0, ValueAndDepth); //中序遍历收集<节点值，深度>

        for(int i =0; i<=maxDep; i++){
            result.add(new ArrayList<>());  //有多少层就新建多少个list
        }
        //开始收集数组，把不同深度的节点值放入不同的List
        for(int i = 0; i<ValueAndDepth.size(); i++){
            List<Integer> couple = ValueAndDepth.get(i); //{5节点值, 1深度}
            List<Integer> depthResult = result.get(couple.get(1)/* 深度对应的容器List*/);
            depthResult.add(couple.get(0));
        }
        return result;
    }

    private void midOrder(TreeNode root, int depth, List<List<Integer>> ValueAndDepth) {
        if(root == null){
            return;
        }
        midOrder(root.left, depth+1, ValueAndDepth);
        List<Integer> couple = new ArrayList<>();
        couple.add(root.val);
        couple.add(depth);
        ValueAndDepth.add(couple);
        maxDep = Math.max(maxDep,depth);
        midOrder(root.right, depth+1, ValueAndDepth);
    }
}
```

#### 思路2: bfs

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if(root==null){
        return result;
    }
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()){
        int size = queue.size();
        List<Integer> deepResult=new ArrayList<>();
        for(int i=0;i<size;i++){
            TreeNode node = queue.poll();
            deepResult.add(node.val);
            if(node.left!=null){
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
        }
        result.add(deepResult);
    }
    return result;
}
```
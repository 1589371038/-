#### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

难度中等734

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

 

**示例 1：**

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

思考：这道题为什么能用单调栈做？

![image-20211123235509386](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211123235509386.png)

在LR之间的排序后，就满足排序了，那么LR的条件是什么？

第一段，严格升序，且所有数字比后面都小

第二段，严格升序，且所有数字都比后面大

寻找L：建立单调增栈，从左往右往右扫描，满足单调性，

另外，遇到数字比栈内小的，需要清除栈内比数字大的，满足大小的要求，这样L的位置就找到了

![image-20211123235907427](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211123235907427.png)

寻找R的过程同理

```java
    public static int findUnsortedSubarray(int[] nums) {
        if(nums==null||nums.length<1){
            return 0;
        }
        Deque<Integer> stack = new ArrayDeque<>();
        int L=nums.length;
        int R=-1;
        for(int i=0;i<nums.length;i++){  //单调增从左往右，寻找L
            while (!stack.isEmpty()&&nums[stack.peek()]>nums[i]){
                L=Math.min(L,stack.pop());
            }
            stack.push(i);
        }
        for(int i=nums.length-1;i>=0;i--){//单调增从右往左，寻找R
            while (!stack.isEmpty()&&nums[stack.peek()]<nums[i]){
                R=Math.max(R,stack.pop());
            }
            stack.push(i);
        }
        return L<R?R-L+1:0;
    }
```

